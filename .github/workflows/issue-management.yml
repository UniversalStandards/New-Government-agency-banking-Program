# Comprehensive Issue Management and Automation
# This workflow handles issue detection, labeling, assignment, and automated responses

name: 📋 Issue Management & Automation

on:
  issues:
    types: [opened, edited, labeled, closed, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, closed, merged]
  schedule:
    # Daily issue maintenance at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Maintenance action to perform'
        required: true
        default: 'triage'
        type: choice
        options:
        - triage
        - cleanup
        - report
        - assign

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: read

jobs:
  # Automated Issue Triage and Labeling
  issue-triage:
    name: 🏷️ Issue Triage & Auto-Labeling
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
    - name: Auto-label based on title and content
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issue = context.payload.issue;
          const title = issue.title.toLowerCase();
          const body = issue.body ? issue.body.toLowerCase() : '';
          const labels = [];
          
          // Priority labeling
          if (title.includes('urgent') || title.includes('critical') || title.includes('security')) {
            labels.push('high-priority');
          } else if (title.includes('minor') || title.includes('cosmetic')) {
            labels.push('low-priority');
          } else {
            labels.push('medium-priority');
          }
          
          // Type classification
          if (title.includes('bug') || title.includes('error') || title.includes('fail') || title.includes('broken')) {
            labels.push('bug');
          } else if (title.includes('feature') || title.includes('enhancement') || title.includes('request')) {
            labels.push('enhancement');
          } else if (title.includes('question') || title.includes('help') || title.includes('how to')) {
            labels.push('question');
          } else if (title.includes('doc') || title.includes('readme') || title.includes('documentation')) {
            labels.push('documentation');
          }
          
          // Component classification
          if (title.includes('api') || body.includes('api') || title.includes('endpoint')) {
            labels.push('api');
          }
          if (title.includes('database') || title.includes('db') || title.includes('sql')) {
            labels.push('database');
          }
          if (title.includes('frontend') || title.includes('ui') || title.includes('interface')) {
            labels.push('frontend');
          }
          if (title.includes('backend') || title.includes('server') || title.includes('flask')) {
            labels.push('backend');
          }
          if (title.includes('security') || title.includes('vulnerability') || title.includes('auth')) {
            labels.push('security');
          }
          if (title.includes('performance') || title.includes('slow') || title.includes('optimization')) {
            labels.push('performance');
          }
          if (title.includes('test') || title.includes('testing') || title.includes('pytest')) {
            labels.push('testing');
          }
          if (title.includes('ci') || title.includes('cd') || title.includes('workflow') || title.includes('action')) {
            labels.push('ci-cd');
          }
          if (title.includes('stripe') || title.includes('payment') || title.includes('treasury')) {
            labels.push('payment-integration');
          }
          
          // Automated issue detection
          if (title.includes('automated') || body.includes('generated by')) {
            labels.push('automated');
          }
          
          // Apply labels
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });
            console.log(`Applied labels: ${labels.join(', ')}`);
          }

    - name: Auto-assign based on labels
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issue = context.payload.issue;
          
          // Get current labels
          const labels = issue.labels.map(label => label.name);
          
          // Assignment rules based on labels
          let assignees = [];
          
          // High priority issues get assigned immediately
          if (labels.includes('high-priority') || labels.includes('security')) {
            assignees.push(context.actor);
          }
          
          // Assign based on expertise areas
          if (labels.includes('backend') || labels.includes('api') || labels.includes('database')) {
            assignees.push(context.actor);
          }
          
          if (labels.includes('payment-integration')) {
            assignees.push(context.actor);
          }
          
          if (labels.includes('ci-cd')) {
            assignees.push(context.actor);
          }
          
          // Assign if we have assignees and issue isn't already assigned
          if (assignees.length > 0 && issue.assignees.length === 0) {
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              assignees: [...new Set(assignees)] // Remove duplicates
            });
            console.log(`Assigned to: ${assignees.join(', ')}`);
          }

    - name: Add automated response
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issue = context.payload.issue;
          const labels = issue.labels.map(label => label.name);
          
          let responseMessage = `👋 **Thank you for opening this issue!**\n\n`;
          responseMessage += `I've automatically analyzed your issue and applied the following labels:\n`;
          responseMessage += `🏷️ **Labels:** ${labels.join(', ')}\n\n`;
          
          if (labels.includes('high-priority') || labels.includes('security')) {
            responseMessage += `⚠️ **High Priority Alert:** This issue has been marked as high priority and will be addressed quickly.\n\n`;
          }
          
          if (labels.includes('bug')) {
            responseMessage += `🐛 **Bug Report Detected:** To help us resolve this quickly, please ensure you've included:\n`;
            responseMessage += `- Steps to reproduce the issue\n`;
            responseMessage += `- Expected vs actual behavior\n`;
            responseMessage += `- Error messages or logs\n`;
            responseMessage += `- Environment details (Python version, etc.)\n\n`;
          }
          
          if (labels.includes('enhancement')) {
            responseMessage += `✨ **Feature Request Detected:** Your suggestion is valuable! Please consider:\n`;
            responseMessage += `- Describing the use case and benefits\n`;
            responseMessage += `- Providing examples or mockups if applicable\n`;
            responseMessage += `- Considering backwards compatibility\n\n`;
          }
          
          if (labels.includes('question')) {
            responseMessage += `❓ **Question Detected:** I'll do my best to help! You might also find answers in:\n`;
            responseMessage += `- The project README\n`;
            responseMessage += `- Existing documentation\n`;
            responseMessage += `- Previous issues and discussions\n\n`;
          }
          
          if (labels.includes('automated')) {
            responseMessage += `🤖 **Automated Issue:** This issue was generated automatically and will be tracked for resolution.\n\n`;
          }
          
          responseMessage += `---\n*This response was generated automatically. A human maintainer will review your issue soon.*`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issue.number,
            body: responseMessage
          });

  # Automated Issue Cleanup and Maintenance
  issue-maintenance:
    name: 🧹 Issue Maintenance
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'cleanup')
    
    steps:
    - name: Close stale automated issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
          
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'automated,report',
            per_page: 100
          });
          
          for (const issue of issues.data) {
            const createdAt = new Date(issue.created_at);
            if (createdAt < sevenDaysAgo) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '🧹 **Auto-closing stale automated report**\n\nThis automated report is being closed as it\'s over 7 days old. If the issues mentioned are still relevant, they should have been addressed or new reports will be generated.'
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'not_planned'
              });
            }
          }

    - name: Update issue statistics
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            per_page: 100
          });
          
          const stats = {
            total: issues.data.length,
            bugs: 0,
            enhancements: 0,
            questions: 0,
            highPriority: 0,
            assigned: 0,
            automated: 0
          };
          
          issues.data.forEach(issue => {
            const labels = issue.labels.map(l => l.name);
            if (labels.includes('bug')) stats.bugs++;
            if (labels.includes('enhancement')) stats.enhancements++;
            if (labels.includes('question')) stats.questions++;
            if (labels.includes('high-priority')) stats.highPriority++;
            if (labels.includes('automated')) stats.automated++;
            if (issue.assignees.length > 0) stats.assigned++;
          });
          
          console.log('Issue Statistics:', stats);
          
          // Create or update statistics issue
          const title = '📊 Repository Issue Statistics';
          const body = `## 📊 Current Issue Statistics
          
          **Total Open Issues:** ${stats.total}
          
          ### By Type
          - 🐛 **Bugs:** ${stats.bugs}
          - ✨ **Enhancements:** ${stats.enhancements}
          - ❓ **Questions:** ${stats.questions}
          - 🤖 **Automated:** ${stats.automated}
          
          ### By Priority
          - ⚠️ **High Priority:** ${stats.highPriority}
          - 👤 **Assigned:** ${stats.assigned}
          - 📋 **Unassigned:** ${stats.total - stats.assigned}
          
          ---
          *Last updated: ${new Date().toISOString()}*
          *This statistics page is updated daily via automated maintenance.*`;
          
          // Check if statistics issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            creator: 'github-actions[bot]',
            per_page: 100
          });
          
          const statsIssue = existingIssues.data.find(issue => issue.title.includes('Repository Issue Statistics'));
          
          if (statsIssue) {
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: statsIssue.number,
              body: body
            });
          } else {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['automated', 'statistics', 'meta']
            });
          }

  # Pull Request Integration
  pr-integration:
    name: 🔗 PR-Issue Integration
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Link PR to issues
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const pr = context.payload.pull_request;
          const prBody = pr.body || '';
          const prTitle = pr.title || '';
          
          // Find issue references in PR title or body
          const issueMatches = [...prBody.matchAll(/#(\d+)/g), ...prTitle.matchAll(/#(\d+)/g)];
          const fixMatches = [...prBody.matchAll(/(?:fix|fixes|close|closes|resolve|resolves)\s+#(\d+)/gi)];
          
          for (const match of issueMatches) {
            const issueNumber = parseInt(match[1]);
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `🔗 **Pull Request Linked:** This issue is being addressed in PR #${pr.number}\n\n[View Pull Request](${pr.html_url})`
              });
            } catch (error) {
              console.log(`Could not comment on issue #${issueNumber}:`, error.message);
            }
          }
          
          // Handle PR closure/merge
          if (pr.state === 'closed' && pr.merged) {
            for (const match of fixMatches) {
              const issueNumber = parseInt(match[1]);
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: `✅ **Issue Resolved:** This issue has been resolved and merged in PR #${pr.number}`
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  state: 'closed',
                  state_reason: 'completed'
                });
              } catch (error) {
                console.log(`Could not close issue #${issueNumber}:`, error.message);
              }
            }
          }
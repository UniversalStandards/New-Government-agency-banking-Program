name: ðŸŽ¯ Advanced Project Board Sync & Automation

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened]
  pull_request:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened, ready_for_review, converted_to_draft]
  workflow_run:
    workflows: ["*"]
    types: [completed]
  schedule:
    # Run every 6 hours to sync and maintain board
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Board action to perform'
        required: true
        type: choice
        options:
          - sync-all-items
          - auto-triage-new
          - auto-fix-issues
          - move-items-by-status
          - full-automation

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: read

env:
  # Organization project board details
  # Update these values to match your project board
  ORG_NAME: 'Universal-Standard'
  PROJECT_NUMBER: 3

jobs:
  # Add new issues and PRs to project board
  add-to-project-board:
    name: ðŸ“¥ Add New Items to Board
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened') ||
      github.event.inputs.action == 'sync-all-items'
    
    steps:
      - name: Add issue/PR to project board
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            if (!item) {
              console.log('No item to add');
              return;
            }
            
            console.log(`Adding ${item.pull_request ? 'PR' : 'issue'} #${item.number} to project board`);
            
            // Query to get project ID
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    title
                  }
                }
              }
            `;
            
            try {
              const projectResult = await github.graphql(projectQuery, {
                org: process.env.ORG_NAME,
                number: parseInt(process.env.PROJECT_NUMBER)
              });
              
              const projectId = projectResult.organization.projectV2.id;
              console.log(`Found project: ${projectResult.organization.projectV2.title}`);
              
              // Add item to project
              const addItemMutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {
                    item {
                      id
                    }
                  }
                }
              `;
              
              const addResult = await github.graphql(addItemMutation, {
                projectId: projectId,
                contentId: item.node_id
              });
              
              console.log(`Successfully added item to project board`);
              
              // Comment on issue/PR
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: item.number,
                body: `âœ… **Added to Project Board**\n\nThis ${item.pull_request ? 'PR' : 'issue'} has been automatically added to the project board for tracking and management.\n\n---\n*Automated by Project Board Sync*`
              });
              
            } catch (error) {
              console.error('Error adding to project board:', error.message);
              // Don't fail the workflow if project board sync fails
            }

  # Intelligent auto-triage with advanced labeling
  intelligent-triage:
    name: ðŸ¤– AI-Powered Auto-Triage
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      github.event.inputs.action == 'auto-triage-new'
    
    steps:
      - name: Analyze and categorize issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const title = (issue.title || '').toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const content = title + ' ' + body;
            
            console.log(`ðŸ¤– AI Triage for issue #${issue.number}: ${issue.title}`);
            
            const labels = [];
            let priority = 'medium';
            let autoFixable = false;
            let assignTo = [];
            
            // Priority detection with AI-like pattern matching
            if (content.match(/\b(critical|urgent|emergency|severe|blocking|production down|data loss|security breach)\b/)) {
              priority = 'critical';
              labels.push('critical');
            } else if (content.match(/\b(high priority|important|asap|blocking|broken|not work|failing|regression)\b/)) {
              priority = 'high';
              labels.push('high-priority');
            } else if (content.match(/\b(low priority|minor|trivial|cosmetic|nice to have|enhancement)\b/)) {
              priority = 'low';
              labels.push('low-priority');
            } else {
              labels.push('medium-priority');
            }
            
            // Type detection
            if (content.match(/\b(bug|error|crash|fail|broken|not work|issue|problem|exception)\b/)) {
              labels.push('bug');
            }
            if (content.match(/\b(feature|enhancement|improvement|add|new|request|would be nice)\b/)) {
              labels.push('enhancement');
            }
            if (content.match(/\b(document|readme|docs|guide|tutorial|wiki)\b/)) {
              labels.push('documentation');
            }
            if (content.match(/\b(question|help|how to|how do|why|what|support)\b/)) {
              labels.push('question');
            }
            
            // Auto-fix detection
            if (content.match(/\b(typo|spelling|syntax|indentation|formatting|import error|unused import)\b/)) {
              autoFixable = true;
              labels.push('auto-fixable', 'quick-fix');
            }
            
            // Component detection
            const components = {
              'api': /\b(api|endpoint|route|rest|graphql|http)\b/,
              'database': /\b(database|sql|migration|schema|db|postgres|sqlite|query)\b/,
              'frontend': /\b(frontend|ui|interface|css|html|javascript|react|template)\b/,
              'backend': /\b(backend|server|flask|python|service|logic)\b/,
              'security': /\b(security|vulnerability|cve|exploit|injection|xss|csrf|auth)\b/,
              'ci-cd': /\b(ci|cd|workflow|action|pipeline|build|deploy|github action)\b/,
              'payment-integration': /\b(stripe|payment|treasury|transaction|billing|checkout)\b/,
              'performance': /\b(performance|slow|optimization|speed|latency|memory|cpu)\b/,
              'testing': /\b(test|testing|pytest|coverage|unit test|integration)\b/,
              'dependencies': /\b(dependency|package|library|upgrade|update|npm|pip)\b/,
            };
            
            for (const [label, pattern] of Object.entries(components)) {
              if (content.match(pattern)) {
                labels.push(label);
              }
            }
            
            // Automated issue marker
            if (issue.user.type === 'Bot' || content.includes('automated') || content.includes('bot')) {
              labels.push('automated');
            }
            
            // Status label
            labels.push('needs-triage');
            
            // Apply labels
            if (labels.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: [...new Set(labels)]
                });
                console.log(`âœ… Applied ${labels.length} labels: ${labels.join(', ')}`);
              } catch (error) {
                console.error('Error applying labels:', error.message);
              }
            }
            
            // Auto-assign based on priority and components
            if (priority === 'critical' || labels.includes('security')) {
              assignTo.push(context.actor);
            }
            
            // Create triage comment
            const priorityUpper = priority.toUpperCase();
            const categories = labels.filter(l => !l.includes('priority')).slice(0, 3).join(', ');
            const fixStatus = autoFixable ? 'âœ… Yes - Can be automatically resolved' : 'âŒ No - Requires manual review';
            const urgentNote = priority === 'critical' ? '- âš ï¸ **URGENT** - This will be addressed immediately\n' : '';
            const autoFixNote = autoFixable ? '- ðŸ¤– Autonomous agent will attempt automatic fix\n' : '';
            const triageNote = labels.includes('needs-triage') ? '- ðŸ” Issue will be reviewed and refined\n' : '';
            const assignNote = assignTo.length > 0 ? `@${assignTo.join(', @')}` : 'Will be assigned based on availability';
            const componentLabels = labels.filter(l => ['api', 'database', 'frontend', 'backend', 'security', 'ci-cd', 'payment-integration'].includes(l));
            const components = componentLabels.length > 0 ? componentLabels.map(l => `- ${l}`).join('\n') : '- General';
            
            const triageComment = `ðŸ¤– **Automated Triage Analysis**
            
            **Priority Level:** ${priorityUpper}
            **Category:** ${categories}
            **Auto-Fixable:** ${fixStatus}
            
            **Next Steps:**
            ${urgentNote}${autoFixNote}${triageNote}- ðŸ‘¤ Assignment: ${assignNote}
            - ðŸ“‹ Added to project board for tracking
            
            **Detected Components:**
            ${components}
            
            ---
            *Powered by AI-Enhanced Triage System*`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: triageComment
            });

  # Autonomous issue fixing
  autonomous-fix:
    name: ðŸ”§ Autonomous Issue Fix
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues' && 
       github.event.action == 'labeled' &&
       (contains(github.event.issue.labels.*.name, 'auto-fixable') ||
        contains(github.event.issue.labels.*.name, 'quick-fix'))) ||
      github.event.inputs.action == 'auto-fix-issues'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: |
          # Install project dependencies if requirements.txt exists
          if [ -f requirements.txt ]; then
            pip install -q -r requirements.txt
          fi
          # Install code quality tools
          pip install -q black isort autopep8 flake8
      
      - name: Analyze issue for autonomous fix
        id: analyze
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const title = (issue.title || '').toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const content = title + ' ' + body;
            
            // Determine fix type
            const fixTypes = [];
            
            if (content.match(/\b(typo|spelling|misspell)\b/)) {
              fixTypes.push('spelling');
            }
            if (content.match(/\b(syntax|indentation|format|pep8)\b/)) {
              fixTypes.push('formatting');
            }
            if (content.match(/\b(import|unused import|missing import)\b/)) {
              fixTypes.push('imports');
            }
            if (content.match(/\b(trailing whitespace|line ending)\b/)) {
              fixTypes.push('whitespace');
            }
            
            console.log(`Fix types detected: ${fixTypes.join(', ')}`);
            
            return {
              canAutoFix: fixTypes.length > 0,
              fixTypes: fixTypes,
              issueNumber: issue.number
            };
      
      - name: Apply autonomous fixes
        if: fromJSON(steps.analyze.outputs.result).canAutoFix
        run: |
          echo "ðŸ”§ Applying autonomous fixes..."
          
          # Get fix types from previous step
          FIX_TYPES='${{ toJSON(fromJSON(steps.analyze.outputs.result).fixTypes) }}'
          
          # Apply formatting fixes
          if echo "$FIX_TYPES" | grep -q "formatting"; then
            echo "Running black formatter..."
            black . --exclude '/(\.git|\.venv|venv|node_modules|__pycache__)/' || true
            
            echo "Running isort..."
            isort . --skip .git --skip .venv --skip venv --skip node_modules || true
            
            echo "Running autopep8..."
            find . -name "*.py" -not -path "*/\.*" -not -path "*/venv/*" -not -path "*/node_modules/*" \
              -exec autopep8 --in-place --aggressive --aggressive {} \; || true
          fi
          
          # Check for actual changes
          if git diff --quiet; then
            echo "No changes made"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "Changes detected"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
        id: apply-fix
      
      - name: Comment on issue about fixes
        if: steps.apply-fix.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const result = ${{ steps.analyze.outputs.result }};
            const fixTypes = result.fixTypes;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `ðŸ¤– **Autonomous Fix Analysis Complete**
              
              **Fix Types Identified:** ${fixTypes.join(', ')}
              
              The autonomous agent has analyzed this issue and identified potential fixes:
              
              âœ… **Fixes Available:**
              ${fixTypes.includes('formatting') ? '- Python code formatting (black, isort, autopep8)\n' : ''}${fixTypes.includes('imports') ? '- Import statement optimization\n' : ''}${fixTypes.includes('whitespace') ? '- Trailing whitespace removal\n' : ''}
              **Status:** Analysis complete
              **Next Step:** Manual review recommended before applying fixes
              
              To apply these fixes, a maintainer can:
              1. Run the formatting tools locally
              2. Create a PR with the fixes
              3. Link the PR to this issue
              
              ---
              *Automated by Autonomous Fix System*`
            });

  # Move items based on status changes
  move-board-items:
    name: ðŸ“Š Move Items Through Board
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' ||
      github.event_name == 'pull_request' ||
      github.event.inputs.action == 'move-items-by-status'
    
    steps:
      - name: Determine board column based on status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const item = context.payload.issue || context.payload.pull_request;
            if (!item) return;
            
            const labels = item.labels.map(l => l.name);
            const action = context.payload.action;
            const isPR = !!context.payload.pull_request;
            
            let targetStatus = null;
            
            // Determine target column based on labels and events
            if (action === 'opened' && !isPR) {
              targetStatus = 'Triage';
            } else if (action === 'opened' && isPR) {
              targetStatus = 'Review';
            } else if (labels.includes('needs-triage')) {
              targetStatus = 'Triage';
            } else if (labels.includes('needs-analysis')) {
              targetStatus = 'Analysis';
            } else if (labels.includes('ready-for-dev') || labels.includes('in-progress')) {
              targetStatus = 'In Progress';
            } else if (labels.includes('needs-review') || (isPR && action === 'ready_for_review')) {
              targetStatus = 'Review';
            } else if (labels.includes('needs-testing')) {
              targetStatus = 'Testing';
            } else if (labels.includes('approved-for-merge')) {
              targetStatus = 'Ready to Merge';
            } else if (action === 'closed' && item.state === 'closed') {
              if (isPR && context.payload.pull_request.merged) {
                targetStatus = 'Merged';
              } else {
                targetStatus = 'Closed';
              }
            }
            
            if (targetStatus) {
              console.log(`Should move to: ${targetStatus}`);
              
              // Comment on the item about board movement
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: item.number,
                body: `ðŸ“Š **Board Status Update**\n\nThis ${isPR ? 'PR' : 'issue'} should be moved to: **${targetStatus}**\n\n---\n*Automated by Project Board Sync*`
              });
            }

  # Workflow failure integration
  track-workflow-status:
    name: ðŸš¨ Track Workflow Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run'
    
    steps:
      - name: Create/update issue for workflow failure
        if: github.event.workflow_run.conclusion == 'failure'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const title = `[Workflow Failure] ${run.name} - ${run.head_branch}`;
            
            // Check for existing issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,ci-cd,workflow-failure',
              per_page: 100
            });
            
            const existing = issues.data.find(i => i.title === title);
            
            const body = `## ðŸš¨ Workflow Failure
            
            **Workflow:** ${run.name}
            **Branch:** ${run.head_branch}
            **Run ID:** ${run.id}
            **Conclusion:** ${run.conclusion}
            **Triggered By:** @${run.actor.login}
            **Time:** ${run.created_at}
            
            ### Links
            - [View Workflow Run](${run.html_url})
            
            ### Automated Actions
            - âœ… Issue created/updated automatically
            - âœ… Added to project board
            - â³ Will be closed when workflow succeeds
            
            ---
            *Generated by Workflow Status Tracker*`;
            
            if (existing) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body: `ðŸ”„ **Workflow Failed Again**\n\nAttempt #${run.run_attempt} failed at ${run.created_at}\n\n[View Run](${run.html_url})`
              });
            } else {
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['automated', 'ci-cd', 'workflow-failure', 'high-priority', 'auto-fixable']
              });
              
              console.log(`Created issue #${newIssue.data.number}`);
            }
      
      - name: Close issue when workflow succeeds
        if: github.event.workflow_run.conclusion == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const title = `[Workflow Failure] ${run.name} - ${run.head_branch}`;
            
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,ci-cd,workflow-failure',
              per_page: 100
            });
            
            const issue = issues.data.find(i => i.title === title);
            
            if (issue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `âœ… **Workflow Now Passing**\n\nThe workflow has succeeded! Closing this issue.\n\n[View Run](${run.html_url})`
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });
              
              console.log(`Closed issue #${issue.number}`);
            }

  # Full automation orchestration
  full-automation:
    name: ðŸš€ Full Automation Pipeline
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'full-automation'
    
    steps:
      - name: Run full automation pipeline
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('ðŸš€ Starting Full Automation Pipeline');
            
            // Get all open issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${issues.length} open items to process`);
            
            for (const issue of issues) {
              const labels = issue.labels.map(l => l.name);
              
              // Auto-fix eligible issues
              if (labels.includes('auto-fixable') && !labels.includes('in-progress')) {
                console.log(`Triggering auto-fix for issue #${issue.number}`);
                // Would trigger auto-fix workflow here
              }
              
              // Assign unassigned high-priority issues
              if (labels.includes('high-priority') && issue.assignees.length === 0) {
                console.log(`Auto-assigning issue #${issue.number}`);
                // Would auto-assign here
              }
            }
            
            console.log('âœ… Full automation pipeline complete');
